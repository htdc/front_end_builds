# This is needed to convert an SSH pubkey into a RSA OpenSSL pubkey that we can
# use to verify the signature. I got this from:
#
# https://github.com/mytestbed/omf/blob/master/omf_common/lib/omf_common/auth/ssh_pub_key_convert.rb
#
# Support for DSA keys was removed from this code as the FEB app doesn't support DSA keys
# See PubKey#verify
#

module FrontEndBuilds
  module Utils
    # Copyright (c) 2012 National ICT Australia Limited (NICTA).
    # This software may be used and distributed solely under the terms of the MIT license (License).
    # You should find a copy of the License in LICENSE.TXT or at http://opensource.org/licenses/MIT.
    # By downloading or using this software you accept the terms and the liability disclaimer in the License.

    require 'base64'
    require 'openssl'

    # This file provides a converter that accepts an SSH public key string
    # and converts it to an OpenSSL::PKey::RSA object for use in verifying
    # received messages.  (DSA support pending).
    #
    class SSHPubKeyConvert
      RSA_OPT_PARAMS    = %i[p q dp dq qi].freeze
      RSA_ASN1_SEQUENCE = (%i[n e d] + RSA_OPT_PARAMS).freeze # https://www.rfc-editor.org/rfc/rfc3447#appendix-A.1.2

      # Unpack a 4-byte unsigned integer from the +bytes+ array.
      #
      # Returns a pair (+u32+, +bytes+), where +u32+ is the extracted
      # unsigned integer, and +bytes+ is the remainder of the original
      # +bytes+ array that follows +u32+.
      #
      def self.unpack_u32(bytes)
        return bytes.unpack("N")[0], bytes[4..-1]
      end

      # Unpack a string from the +bytes+ array.  Exactly +len+ bytes will
      # be extracted.
      #
      # Returns a pair (+string+, +bytes+), where +string+ is the
      # extracted string (of length +len+), and +bytes+ is the remainder
      # of the original +bytes+ array that follows +string+.
      #
      def self.unpack_string(bytes, len)
        return bytes.unpack("A#{len}")[0], bytes[len..-1]
      end

      # Convert a string in SSH public key format to a key object
      # suitable for use with OpenSSL.  If the key is an RSA key then an
      # OpenSSL::PKey::RSA object is returned.  If the key is a DSA key
      # then an OpenSSL::PKey::DSA object is returned.  In either case,
      # the object returned is suitable for encrypting data or verifying
      # signatures, but cannot be used for decrypting or signing.
      #
      # The +keystring+ should be a single line, as per an SSH public key
      # file as generated by +ssh-keygen+, or a line from an SSH
      # +authorized_keys+ file.
      #
      def self.convert(keystring)
        (_, b64, _) = keystring.split(' ')
        raise ArgumentError, "Invalid SSH public key '#{keystring}'" if b64.nil?

        decoded_key = Base64.decode64(b64)
        (n, bytes) = unpack_u32(decoded_key)
        (keytype, bytes) = unpack_string(bytes, n)

        if keytype == "ssh-rsa"
          (n, bytes) = unpack_u32(bytes)
          (estr, bytes) = unpack_string(bytes, n)
          (n, bytes) = unpack_u32(bytes)
          (nstr, bytes) = unpack_string(bytes, n)

          rsa_params = { n: OpenSSL::BN.new(nstr, 2), e: OpenSSL::BN.new(estr, 2) }

          # support SSL 2
          if Gem::Version.new(OpenSSL::VERSION) >= Gem::Version.new('3.0.0')
            create_rsa_key_using_der(rsa_params)
          elsif OpenSSL::PKey::RSA.new.respond_to?(:set_key)
            create_rsa_key_using_sets(rsa_params)
          else
            create_rsa_key_using_accessors(rsa_params)
          end
        else
          # anything non-RSA is not supported
          # this part edited by TED
          raise "Unsupported key type: #{keytype}"
        end
      end

      def self.create_rsa_key_using_der(rsa_parameters)
        validate_rsa_parameters!(rsa_parameters)

        sequence = RSA_ASN1_SEQUENCE.each_with_object([]) do |key, arr|
          next if rsa_parameters[key].nil?

          arr << OpenSSL::ASN1::Integer.new(rsa_parameters[key])
        end

        if sequence.size > 2 # Append "two-prime" version for private key
          sequence.unshift(OpenSSL::ASN1::Integer.new(0))

          raise JWT::JWKError, 'Creating a RSA key with a private key requires the CRT parameters to be defined' if sequence.size < RSA_ASN1_SEQUENCE.size
        end

        OpenSSL::PKey::RSA.new(OpenSSL::ASN1::Sequence(sequence).to_der)
      end

      def self.create_rsa_key_using_sets(rsa_parameters)
        validate_rsa_parameters!(rsa_parameters)

        OpenSSL::PKey::RSA.new.tap do |rsa_key|
          rsa_key.set_key(rsa_parameters[:n], rsa_parameters[:e], rsa_parameters[:d])
          rsa_key.set_factors(rsa_parameters[:p], rsa_parameters[:q]) if rsa_parameters[:p] && rsa_parameters[:q]
          rsa_key.set_crt_params(rsa_parameters[:dp], rsa_parameters[:dq], rsa_parameters[:qi]) if rsa_parameters[:dp] && rsa_parameters[:dq] && rsa_parameters[:qi]
        end
      end

      def self.create_rsa_key_using_accessors(rsa_parameters) # rubocop:disable Metrics/AbcSize
        validate_rsa_parameters!(rsa_parameters)

        OpenSSL::PKey::RSA.new.tap do |rsa_key|
          rsa_key.n = rsa_parameters[:n]
          rsa_key.e = rsa_parameters[:e]
          rsa_key.d = rsa_parameters[:d] if rsa_parameters[:d]
          rsa_key.p = rsa_parameters[:p] if rsa_parameters[:p]
          rsa_key.q = rsa_parameters[:q] if rsa_parameters[:q]
          rsa_key.dmp1 = rsa_parameters[:dp] if rsa_parameters[:dp]
          rsa_key.dmq1 = rsa_parameters[:dq] if rsa_parameters[:dq]
          rsa_key.iqmp = rsa_parameters[:qi] if rsa_parameters[:qi]
        end
      end

      def self.validate_rsa_parameters!(rsa_parameters)
        return unless rsa_parameters.key?(:d)

        parameters = RSA_OPT_PARAMS - rsa_parameters.keys
        return if parameters.empty? || parameters.size == RSA_OPT_PARAMS.size

        raise 'When one of p, q, dp, dq or qi is given all the other optimization parameters also needs to be defined' # https://www.rfc-editor.org/rfc/rfc7518.html#section-6.3.2
      end
    end
  end
end
